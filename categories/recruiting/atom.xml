<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: recruiting | sharp bites]]></title>
  <link href="http://www.sharpbites.com/categories/recruiting/atom.xml" rel="self"/>
  <link href="http://www.sharpbites.com/"/>
  <updated>2013-04-24T09:38:11+02:00</updated>
  <id>http://www.sharpbites.com/</id>
  <author>
    <name><![CDATA[alberto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[I've read: Peopleware]]></title>
    <link href="http://www.sharpbites.com/2010/11/26/ive-read-peopleware/"/>
    <updated>2010-11-26T00:00:00+01:00</updated>
    <id>http://www.sharpbites.com/2010/11/26/ive-read-peopleware</id>
    <content type="html"><![CDATA[<div class='post'>
'Peopleware' is one of those classic books of our profession, a must-read. Unfortunately, it's not easy to grab a copy of it on the stores (it may have been discontinued, I'm not sure).&nbsp;After a failed attempt to borrow it from <a href="http://twitter.com/jmbeas">Jose Manuel Beas</a>,&nbsp;a few weeks ago, I finally got the chance to read it (thanks <a href="http://twitter.com/rubenbpv">Rubén</a>!).<br /><br />All I can say is, if you have the chance, read it! Just so you can have a glimpse at it, here are some notes I&nbsp;took from it. Most are direct quotes,&nbsp;although&nbsp;I reworded a few to&nbsp;synthesize.<br /><br /><span class="Apple-style-span" style="font-size: large;">Productivity</span><br /><span class="Apple-style-span" style="font-size: large;"><span class="Apple-style-span" style="font-size: small;">As long as workers are crowded into noisy, disruptive space, it's not worth improving anything but the workspace.</span></span><br />Experiments showed projects without deadlines had the best productivity.<br />Better performance can be explained entirely by more effective ways of handling people, modifying the workplace and corporate culture.<br />Developers main work is human communication to organize the user's expressions of needs into formal procedure.<br />People won't work better under a lot of pressure.<br />The manager's function is not to make people work, but to make it possible for people to work.<br />Best people outperform the worst by 10 and the median performer by 2.5.<br />Years of experience are not correlated to productivity.<br />Interrupting flow not only causes disruption but frustration.<br />There are two types of work: Individual work is noise sensitive and needs flow.&nbsp;Group work is noise producing. Adapt your workspace to make both kinds of work possible.<br />Measure and try to maximize flow time, but don't let managers access to data.<br />Ignoring the phone must be accepted by corporate policy.<br />Ask people about their workspace conditions, what affects their productivity.<br />Listening to music uses the right part of the braing, which is responsible for creativity.<br />Encourage teams to customize their space.<br /><br /><span class="Apple-style-span" style="font-size: large;">People</span><br />People who work for you will be more or less the same at the end as they were at the beginning, so they better be right for the job from the start.<br />Find the right people, make them happy, turn them loose.<br />Success or failure is in the cards from the moment the team is formed and the initial directions set out.<br />Corporate pressure is pushing towards the company average, encouraging you to hire people that look, sound and think like everybody else.<br /><br /><span class="Apple-style-span" style="font-size: large;">Hiring</span><br />(Tell about hiring a juggler) 'Don't you want to see me juggle?'<br />Make people bring their code portfolio for interviews.<br />Make candidates prepare an audition with the team 10-to-15 minute presentation on some aspect of past work.<br /><br /><span class="Apple-style-span" style="font-size: large;">Good organizations</span><br />Late promotion is a sign of health.<br />With a low and flat hierarchy, people at the lowest level have, on average more years of experience.<br />Strive to be the best<br />Grow a community feeling.<br />Focus on long term benefits.<br />Widespread sense that you are expected to stay<br />Invest in personal growth<br />Retrain your people<br />When you automate a system, you make it deterministic, so it looses its self-healing ability. A&nbsp;<b>M</b>ethodology (capital 'M' here) can produce the same results on you organization.<br />To achieve convergence of methods, use training, tools and peer review.<br />Don't declare something a standard until it is a de facto standard.<br />Hawtorne effect (experiment of raising and lowering the light) People perform better when they are trying something new.<br />You have to make non-standard approaches to the rule. Whatever standard there is should be brief and gentle.<br />Let a hundred flowers blossom and let a hundred schools of thought contend. (Mao Tse-tung)<br /><br /><span class="Apple-style-span" style="font-size: large;">Jelled teams</span><br />Productive teams = challenge + team interaction<br />They have momentum.<br />They have a goal<br />The purpose of a team is not goal attainment but goal achievement.<br />People on jelled teams are often so involved you have to remind them&nbsp;that what they are trying to accomplish is not winning a war.<br />Jelled teams have low turnover and strong sense of identity.<br />Money, status and position for advance matter a lot less. Enjoyment is an obvious sign.<br />You can't make teams jell, just act to improve the odds.<br />Teamicide techniques:<br /><br /><ul><li>Defensive management</li><li>Bureaucracy</li><li>Physical&nbsp;separation</li><li>Fragmentation of people's time</li><li>Quality reduction</li><li>Phony deadlines</li><li>Clique control</li></ul><br />Good managers provide opportunities for the team to succeed together. The best success is the one in which there is no evident management. The best boss is the one who can manage without the team knowing they've been managed.<br /><br />Growing jelled teams:<br /><br /><ul><li>Give people autonomy and responsibility</li><li>Let them work alone, without constant supervision</li><li>They break the rules when they believe in it</li><li>Let them choose mates and projects</li><li>Let them exercise their natural authority in their area of expertise.</li></ul><br />Chemistry for team formation:<br /><br /><ul><li>Make a cult of quality</li><li>Provide satisfying confirmation</li><li>Build a sense of eliteness</li><li>Allow and encourage heterogeneity</li><li>Preserve and protect successful teams.</li><li>Provide strategic but not tactical direction</li></ul><br /><br /><span class="Apple-style-span" style="font-size: large;">Chaos (it is not that bad!)</span><br />Small amounts of disorder are benefitial<br />Pilot projects, war games, brainstorming, provocative training experiences, training, trips, conferences, celebrations, retreats,...<br /><br />If your corporation is fortunate enough to have a self-motivated superachiever on-board, it's enough to say "Define your own job"<br />"Free electrons" have a strong role in choosing their own orbits.<br /><br /><span class="Apple-style-span" style="font-size: large;">Being a Change Agent</span><br />Focus on one thing to change. Raise people's consciousness of it, so they help you change it.<br />Be careful with motivational posters, they can have the opposite effect.<br />Fuck overtime.<br />Competition inhibits coaching.<br />Any action that rewards team members differently is likely to foster competition.<br />The success of the individual should be tied to the success of the whole.<br />People hate change. Any change.<br />Your enemies are blindly loyals and militantly opposed to change.<br />The fundamental response to change is not logical, but emotional.<br />Celebrate the old as a way to help make change happen.<br />Be aware that chaos is an integral part of change. Otherwise, you mistake it for the new status quo and will want to change back.<br />Change always involves chaos, it is necessary and can't be shortcut. The more painful the chaos, the greater the perceived value of the new status quo.<br />Change won't even get started unless people feel safe when they know they won't be demeaned for proposing or trying a change.<br />Change only has a chance of&nbsp;succeeding&nbsp;if failure is also&nbsp;OK.<br /><br /><span class="Apple-style-span" style="font-size: large;">Organizational learning</span><br />Learning is limited by an organization's ability to keep its people.<br />If the retrained people leave, investment is lost and learning is gone.<br />Successful&nbsp;learning organizations are always characterized by strong middle management. In order for a vital learning center to form, middle managers must communicate with each other and learn to work together in effective harmony.<br /><br /><span class="Apple-style-span" style="font-size: large;">Waste</span><br />The ultimate management sin is wasting people's time.<br />Organizations have need of ceremony.<br />Ceremony is good when it fulfills a need for appreciation by the team.<br />Early&nbsp;over-staffing&nbsp;is waste.<br />Fragmented time is waste, it breaks flow.<br /><br /><span class="Apple-style-span" style="font-size: large;">Community</span><br />Building a community makes a difference, but requires talent, courage and creativity. And an enormous invest of time, to be, at best, the catalyst.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Agile enterprise culture]]></title>
    <link href="http://www.sharpbites.com/2009/09/08/agile-enterprise-culture/"/>
    <updated>2009-09-08T00:00:00+02:00</updated>
    <id>http://www.sharpbites.com/2009/09/08/agile-enterprise-culture</id>
    <content type="html"><![CDATA[<div class='post'>
<div style="width:425px;text-align:left" id="__ss_1798664"><a style="font:14px Helvetica,Arial,Sans-serif;display:block;margin:12px 0 3px 0;text-decoration:underline;" href="http://www.slideshare.net/reed2001/culture-1798664" title="Culture">Culture</a><object style="margin:0px" width="425" height="355"><param name="movie" value="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=culture9-090801103430-phpapp02&rel=0&stripped_title=culture-1798664" /><param name="allowFullScreen" value="true"/><param name="allowScriptAccess" value="always"/><embed src="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=culture9-090801103430-phpapp02&rel=0&stripped_title=culture-1798664" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="355"></embed></object><div style="font-size:11px;font-family:tahoma,arial;height:26px;padding-top:2px;">View more <a style="text-decoration:underline;" href="http://www.slideshare.net/">presentations</a> from <a style="text-decoration:underline;" href="http://www.slideshare.net/reed2001">Reed Hastings</a>.</div></div>Some highlights:<br /><blockquote>"The real company values, as opposed to the nice-sounding values, are shown by who gets rewarded, promoted or let-go"</blockquote><blockquote>"The Keeper Test: 'Which of my people, if they told me they were leaving in two months for a similar job at a peer company, would I fight hard to keep?'"</blockquote><blockquote>"You should periodically ask your manager: 'If I told you I were leaving, how hard would you work to change my mind?'"</blockquote><blockquote>"In procedural work, the best are 2x better than the average."</blockquote><blockquote>"In creative work, the best are 10x better than the average, so huge premium on creating effective teams of the best"</blockquote><blockquote>"Vacation policy and Tracking: there is no policy or tracking"</blockquote><blockquote>"One outstanding employee gets more done and costs less than two adequate employees"</blockquote><blockquote>"It is a good idea, not a traitorous idea, to understand what other firms would pay you, by interviewing and talking to peers at other companies"</blockquote><blockquote>Three Tests for Top of Market for a Person:<br />1. What could person get elsewhere?<br />2. What would we pay for replacement?<br />3. What would we pay to keep person?<br /></blockquote><blockquote>"We should celebrate someone leaving for a bigger job that we didn't have available to offer them"</blockquote><blockquote>"If manager would promote employee to keep them [...], manager should promote him now, and not wait"</blockquote><blockquote>"Mediocre colleagues and unchallenging work is what kills progress of a person's skills"</blockquote></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[It's the people, stupid!]]></title>
    <link href="http://www.sharpbites.com/2009/08/15/its-people-stupid/"/>
    <updated>2009-08-15T00:00:00+02:00</updated>
    <id>http://www.sharpbites.com/2009/08/15/its-people-stupid</id>
    <content type="html"><![CDATA[<div class='post'>
<blockquote>You need people who are passionate about what they do. People who care about their craft — and actually think of it as a craft. People who take pride in their work, regardless of the monetary reward involved. People who sweat the details even if 95% of folks don't know the difference. People who want to build something great and won't settle for less. [...]Anyhow, when you find those people, hold onto them. In the end, the folks on your team will make or break your project — and your company.<br /><cite> <a href="http://gettingreal.37signals.com/">Getting Real</a>, <a href="http://www.37signals.com/">37signals</a></cite></blockquote></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ayende's Challenge #2: The directory tree]]></title>
    <link href="http://www.sharpbites.com/2008/04/14/ayendes-challenge-2-directory-tree/"/>
    <updated>2008-04-14T00:00:00+02:00</updated>
    <id>http://www.sharpbites.com/2008/04/14/ayendes-challenge-2-directory-tree</id>
    <content type="html"><![CDATA[<div class='post'>
Here comes a new challenge.<br /><blockquote>Given a set of versioned file, you need to cache them locally. Note that IPersistentCache semantics means that if you put a value in it, is is always going to remain there.</blockquote><br /><br />I'm glad this one wasn't on a real interview, it took me quite some time to get this right, I guess I wouldn't have get the job this time. xD<br /><br />You can download the source from <a href="http://www.assembla.com/spaces/sand-box/documents/aMV1tEcLGr3zM9ab7jnrAJ/download?filename=Ayende%27s+Challenge+%232%3A+The+directory+Tree.zip">here</a> or see it below. :)<br /><br /><br /><!--<br />{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue255;\red43\green145\blue175;}??\fs20     \cf3 public\cf0  \cf3 interface\cf0  \cf4 IPersistentCache\par ??\cf0     \{\par ??        \cf3 void\cf0  Set(\cf3 string\cf0  key, \cf3 params\cf0  \cf3 string\cf0 [] items);\par ??        \cf3 string\cf0 [] Get(\cf3 string\cf0  key);\par ??        \cf4 ICollection\cf0 &lt;\cf3 string\cf0 &gt; Keys();\par ??    \}\par ??\par ??    \cf3 public\cf0  \cf3 class\cf0  \cf4 PersistentCache\cf0  : \cf4 IPersistentCache\par ??\cf0     \{\par ??        \cf3 readonly\cf0  \cf4 Dictionary\cf0 &lt;\cf3 string\cf0 , \cf4 List\cf0 &lt;\cf3 string\cf0 &gt;&gt; cache = \cf3 new\cf0  \cf4 Dictionary\cf0 &lt;\cf3 string\cf0 , \cf4 List\cf0 &lt;\cf3 string\cf0 &gt;&gt;();\par ??        \cf3 public\cf0  \cf3 void\cf0  Set(\cf3 string\cf0  key, \cf3 params\cf0  \cf3 string\cf0 [] items)\par ??        \{\par ??            \cf3 if\cf0  (cache.ContainsKey(key))\par ??               cache[key].AddRange(items);\par ??            \cf3 else\par ??\cf0                cache[key] = \cf3 new\cf0  \cf4 List\cf0 &lt;\cf3 string\cf0 &gt;(items);\par ??        \}\par ??\par ??        \cf3 public\cf0  \cf3 string\cf0 [] Get(\cf3 string\cf0  key)\par ??        \{\par ??            \cf3 if\cf0  (!cache.ContainsKey(key))\par ??                \cf3 return\cf0  \cf3 null\cf0 ;\par ??            \cf3 return\cf0  cache[key].ToArray();\par ??        \}\par ??\par ??        \cf3 public\cf0  \cf4 ICollection\cf0 &lt;\cf3 string\cf0 &gt; Keys()\par ??        \{\par ??            \cf3 return\cf0  cache.Keys;\par ??        \}\par ??    \}}<br />--><br /><div style="font-family: Courier New; font-size: 10pt; color: black; background: white;"><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">interface</span> <span style="color: #2b91af;">IPersistentCache</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">void</span> Set(<span style="color: blue;">string</span> key, <span style="color: blue;">params</span> <span style="color: blue;">string</span>[] items);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] Get(<span style="color: blue;">string</span> key);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">ICollection</span>&lt;<span style="color: blue;">string</span>&gt; Keys();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">PersistentCache</span> : <span style="color: #2b91af;">IPersistentCache</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">readonly</span> <span style="color: #2b91af;">Dictionary</span>&lt;<span style="color: blue;">string</span>, <span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">string</span>&gt;&gt; cache = <span style="color: blue;">new</span> <span style="color: #2b91af;">Dictionary</span>&lt;<span style="color: blue;">string</span>, <span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">string</span>&gt;&gt;();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> Set(<span style="color: blue;">string</span> key, <span style="color: blue;">params</span> <span style="color: blue;">string</span>[] items)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (cache.ContainsKey(key))</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; cache[key].AddRange(items);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">else</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; cache[key] = <span style="color: blue;">new</span> <span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">string</span>&gt;(items);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">string</span>[] Get(<span style="color: blue;">string</span> key)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (!cache.ContainsKey(key))</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">null</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> cache[key].ToArray();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: #2b91af;">ICollection</span>&lt;<span style="color: blue;">string</span>&gt; Keys()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> cache.Keys;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /></div><br /><br /><!--<br />{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue255;\red43\green145\blue175;\red163\green21\blue21;}??\fs20     \cf3 public\cf0  \cf3 class\cf0  \cf4 VersionedFile\par ??\cf0     \{\par ??        \cf3 public\cf0  \cf3 int\cf0  Version \{ \cf3 get\cf0 ; \cf3 set\cf0 ; \}\par ??        \cf3 public\cf0  \cf3 string\cf0  Name \{ \cf3 get\cf0 ; \cf3 set\cf0 ; \}\par ??\par ??        \cf3 public\cf0  \cf3 override\cf0  \cf3 string\cf0   ToString()\par ??        \{\par ??            \cf3 return\cf0  Name + \cf5 ";"\cf0  + Version;\par ??        \}\par ??\par ??        \cf3 public\cf0  \cf3 static\cf0  \cf4 VersionedFile\cf0  FromString(\cf3 string\cf0  versionedFileString)\par ??        \{\par ??            \cf3 string\cf0 [] nameAndVersion = versionedFileString.Split(\cf5 ';'\cf0 );\par ??            \cf3 return\cf0  \cf3 new\cf0  \cf4 VersionedFile\par ??\cf0                        \{\par ??                           Name = nameAndVersion[0],\par ??                           Version = \cf3 int\cf0 .Parse(nameAndVersion[1])\par ??                       \};\par ??        \}\par ??\par ??        \cf3 public\cf0  \cf3 string\cf0  GetParent()\par ??        \{\par ??            \cf3 int\cf0  index = Name.LastIndexOf(\cf5 "/"\cf0 );\par ??            \cf3 if\cf0  (index &gt; 0)\par ??                \cf3 return\cf0  Name.Substring(0, index);\par ??            \cf3 if\cf0  (index == 0 &amp;&amp; Name.Length &gt; 1)\par ??                \cf3 return\cf0  \cf5 "/"\cf0 ;\par ??            \cf3 return\cf0  \cf3 null\cf0 ;\par ??        \}\par ??    \}}<br />--><br /><div style="font-family: Courier New; font-size: 10pt; color: black; background: white;"><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">VersionedFile</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">int</span> Version { <span style="color: blue;">get</span>; <span style="color: blue;">set</span>; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">string</span> Name { <span style="color: blue;">get</span>; <span style="color: blue;">set</span>; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">override</span> <span style="color: blue;">string</span>&nbsp; ToString()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> Name + <span style="color: #a31515;">";"</span> + Version;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">static</span> <span style="color: #2b91af;">VersionedFile</span> FromString(<span style="color: blue;">string</span> versionedFileString)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] nameAndVersion = versionedFileString.Split(<span style="color: #a31515;">';'</span>);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Name = nameAndVersion[0],</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Version = <span style="color: blue;">int</span>.Parse(nameAndVersion[1])</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; };</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">string</span> GetParent()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">int</span> index = Name.LastIndexOf(<span style="color: #a31515;">"/"</span>);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (index &gt; 0)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> Name.Substring(0, index);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (index == 0 &amp;&amp; Name.Length &gt; 1)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: #a31515;">"/"</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">null</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /></div><br /><br /><!--<br />{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue255;\red43\green145\blue175;}??\fs20     \cf3 public\cf0  \cf3 enum\cf0  \cf4 Recursion\par ??\cf0     \{\par ??        None,\par ??        OneLevel,\par ??        Full\par ??    \}\par ??\par ??    \cf3 public\cf0  \cf3 interface\cf0  \cf4 IFileSystemCache\par ??\cf0     \{\par ??        \cf3 void\cf0  Add(\cf4 VersionedFile\cf0 [] versionedFiles);\par ??        \cf3 string\cf0 [] ListFilesAndFolders(\cf3 string\cf0  root, \cf3 int\cf0  version, \cf4 Recursion\cf0  recursion);\par ??    \}\par ??\par ??    \cf3 public\cf0  \cf3 class\cf0  \cf4 FileSystemCache\cf0  : \cf4 IFileSystemCache\par ??\cf0     \{\par ??        \cf3 readonly\cf0  \cf4 IPersistentCache\cf0  cache;\par ??\par ??        \cf3 public\cf0  FileSystemCache(\cf4 IPersistentCache\cf0  cache)\par ??        \{\par ??            \cf3 this\cf0 .cache = cache;\par ??        \}\par ??\par ??        \cf3 private\cf0  \cf3 void\cf0  WriteToPersistentCache(\cf4 VersionedFile\cf0  file)\par ??        \{\par ??           WriteToPersistentCache(file.Name, file);\par ??        \}\par ??\par ??        \cf3 private\cf0  \cf3 void\cf0  WriteToPersistentCache(\cf3 string\cf0  key, \cf4 VersionedFile\cf0  file)\par ??        \{\par ??            cache.Set(key, file.ToString());\par ??        \}\par ??\par ??        \cf3 public\cf0  \cf3 void\cf0  Add(\cf4 VersionedFile\cf0 [] versionedFiles)\par ??        \{\par ??            \cf3 foreach\cf0  (\cf4 VersionedFile\cf0  file \cf3 in\cf0  versionedFiles)\par ??            \{\par ??                WriteToPersistentCache(file);\par ??                \cf3 string\cf0  parent = file.GetParent();\par ??                \cf3 if\cf0  (parent != \cf3 null\cf0 )\par ??                    WriteToPersistentCache(parent, file);\par ??            \}\par ??        \}\par ??\par ??        \cf3 public\cf0  \cf3 string\cf0 [] ListFilesAndFolders(\cf3 string\cf0  root, \cf3 int\cf0  version, \cf4 Recursion\cf0  recursion)\par ??        \{\par ??            \cf3 switch\cf0  (recursion)\par ??            \{\par ??                \cf3 case\cf0  \cf4 Recursion\cf0 .None:\par ??                    \cf3 return\cf0  GetFolder(root, version);\par ??                \cf3 case\cf0  \cf4 Recursion\cf0 .OneLevel:\par ??                    \cf3 return\cf0  GetFilesAndFolder(root, version);\par ??                \cf3 case\cf0  \cf4 Recursion\cf0 .Full:\par ??                    \cf3 return\cf0  GetAllFilesAndFoldersIn(root, version, \cf3 false\cf0 );\par ??                \cf3 default\cf0 :\par ??                    \cf3 return\cf0  \cf3 null\cf0 ;\par ??            \}\par ??        \}\par ??\par ??\par ??        \cf3 private\cf0  \cf3 static\cf0  \cf3 string\cf0 [] FilterByVersion(\cf3 string\cf0 [] strings, \cf3 int\cf0  version)\par ??        \{\par ??            \cf3 var\cf0  versionedfiles = \cf3 new\cf0  \cf4 List\cf0 &lt;\cf3 string\cf0 &gt;();\par ??            \cf3 foreach\cf0  (\cf3 string\cf0  s \cf3 in\cf0  strings)\par ??            \{\par ??                \cf3 var\cf0  versionedFile = \cf4 VersionedFile\cf0 .FromString(s);\par ??                \cf3 if\cf0  (versionedFile.Version == version)\par ??                    versionedfiles.Add(versionedFile.Name);\par ??            \}\par ??            \cf3 return\cf0  versionedfiles.ToArray();\par ??        \}\par ??\par ??        \cf3 private\cf0  \cf3 string\cf0 [] GetFilesAndFolder(\cf3 string\cf0  folderPath, \cf3 int\cf0  version)\par ??        \{\par ??            \cf3 return\cf0  FilterByVersion(cache.Get(folderPath), version);\par ??        \}\par ??\par ??        \cf3 private\cf0  \cf3 string\cf0 [] GetFolder(\cf3 string\cf0  folderPath, \cf3 int\cf0  version)\par ??        \{\par ??            \cf3 var\cf0  files = GetFilesAndFolder(folderPath, version);\par ??            \cf3 if\cf0  (files == \cf3 null\cf0 )\par ??               \cf3 return\cf0  \cf3 null\cf0 ;\par ??            \cf3 foreach\cf0  (\cf3 string\cf0  file \cf3 in\cf0  files)\par ??            \{\par ??                \cf3 if\cf0  (file == folderPath)\par ??                \{\par ??                    \cf3 return\cf0  \cf3 new\cf0  []\{folderPath\};\par ??                \}\par ??            \}\par ??            \cf3 return\cf0  \cf3 null\cf0 ;\par ??        \}\par ??\par ??        \cf3 private\cf0  \cf3 string\cf0 [] GetAllFilesAndFoldersIn(\cf3 string\cf0  folderPath, \cf3 int\cf0  version, \cf3 bool\cf0  rootIncluded)\par ??        \{\par ??            \cf3 var\cf0  allFiles = \cf3 new\cf0  \cf4 List\cf0 &lt;\cf3 string\cf0 &gt;();\par ??            \cf3 var\cf0  files = GetFilesAndFolder(folderPath, version);\par ??            \cf3 foreach\cf0  (\cf3 string\cf0  file \cf3 in\cf0  files)\par ??            \{\par ??                \cf3 if\cf0  (file != folderPath)\par ??                \{\par ??                    allFiles.AddRange(GetAllFilesAndFoldersIn(file, version, \cf3 true\cf0 ));\par ??                    allFiles.Add(file);\par ??                \}\par ??                \cf3 else\cf0  \cf3 if\cf0  (!rootIncluded)\par ??                    allFiles.Add(file);\par ??            \}\par ??            \cf3 return\cf0  allFiles.ToArray();\par ??        \}\par ??    \}}<br />--><br /><div style="font-family: Courier New; font-size: 10pt; color: black; background: white;"><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">enum</span> <span style="color: #2b91af;">Recursion</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; None,</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; OneLevel,</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Full</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">interface</span> <span style="color: #2b91af;">IFileSystemCache</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">void</span> Add(<span style="color: #2b91af;">VersionedFile</span>[] versionedFiles);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] ListFilesAndFolders(<span style="color: blue;">string</span> root, <span style="color: blue;">int</span> version, <span style="color: #2b91af;">Recursion</span> recursion);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">FileSystemCache</span> : <span style="color: #2b91af;">IFileSystemCache</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">readonly</span> <span style="color: #2b91af;">IPersistentCache</span> cache;</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> FileSystemCache(<span style="color: #2b91af;">IPersistentCache</span> cache)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">this</span>.cache = cache;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: blue;">void</span> WriteToPersistentCache(<span style="color: #2b91af;">VersionedFile</span> file)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; WriteToPersistentCache(file.Name, file);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: blue;">void</span> WriteToPersistentCache(<span style="color: blue;">string</span> key, <span style="color: #2b91af;">VersionedFile</span> file)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cache.Set(key, file.ToString());</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> Add(<span style="color: #2b91af;">VersionedFile</span>[] versionedFiles)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">foreach</span> (<span style="color: #2b91af;">VersionedFile</span> file <span style="color: blue;">in</span> versionedFiles)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WriteToPersistentCache(file);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span> parent = file.GetParent();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (parent != <span style="color: blue;">null</span>)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WriteToPersistentCache(parent, file);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">string</span>[] ListFilesAndFolders(<span style="color: blue;">string</span> root, <span style="color: blue;">int</span> version, <span style="color: #2b91af;">Recursion</span> recursion)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">switch</span> (recursion)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">case</span> <span style="color: #2b91af;">Recursion</span>.None:</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> GetFolder(root, version);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">case</span> <span style="color: #2b91af;">Recursion</span>.OneLevel:</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> GetFilesAndFolder(root, version);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">case</span> <span style="color: #2b91af;">Recursion</span>.Full:</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> GetAllFilesAndFoldersIn(root, version, <span style="color: blue;">false</span>);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">default</span>:</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">null</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: blue;">static</span> <span style="color: blue;">string</span>[] FilterByVersion(<span style="color: blue;">string</span>[] strings, <span style="color: blue;">int</span> version)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> versionedfiles = <span style="color: blue;">new</span> <span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">string</span>&gt;();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">foreach</span> (<span style="color: blue;">string</span> s <span style="color: blue;">in</span> strings)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> versionedFile = <span style="color: #2b91af;">VersionedFile</span>.FromString(s);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (versionedFile.Version == version)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; versionedfiles.Add(versionedFile.Name);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> versionedfiles.ToArray();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: blue;">string</span>[] GetFilesAndFolder(<span style="color: blue;">string</span> folderPath, <span style="color: blue;">int</span> version)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> FilterByVersion(cache.Get(folderPath), version);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: blue;">string</span>[] GetFolder(<span style="color: blue;">string</span> folderPath, <span style="color: blue;">int</span> version)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> files = GetFilesAndFolder(folderPath, version);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (files == <span style="color: blue;">null</span>)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">null</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">foreach</span> (<span style="color: blue;">string</span> file <span style="color: blue;">in</span> files)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (file == folderPath)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">new</span> []{folderPath};</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">null</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: blue;">string</span>[] GetAllFilesAndFoldersIn(<span style="color: blue;">string</span> folderPath, <span style="color: blue;">int</span> version, <span style="color: blue;">bool</span> rootIncluded)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> allFiles = <span style="color: blue;">new</span> <span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">string</span>&gt;();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> files = GetFilesAndFolder(folderPath, version);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">foreach</span> (<span style="color: blue;">string</span> file <span style="color: blue;">in</span> files)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (file != folderPath)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; allFiles.AddRange(GetAllFilesAndFoldersIn(file, version, <span style="color: blue;">true</span>));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; allFiles.Add(file);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">else</span> <span style="color: blue;">if</span> (!rootIncluded)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; allFiles.Add(file);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> allFiles.ToArray();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /></div><br /><br /><br />And there are a few tests too, just to make sure everything works as intended. ;)<br /><br /><!--<br />{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red163\green21\blue21;}??\fs20         [\cf3 Test\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  get__should_return_the_files__when_key_exists()\par ??        \{\par ??            \cf4 var\cf0  target = \cf4 new\cf0  \cf3 PersistentCache\cf0 ();\par ??            \cf4 var\cf0  key = \cf5 "/"\cf0 ;\par ??            \cf4 string\cf0 [] values = \{ \cf5 "/"\cf0 , \cf5 "/foo"\cf0  \};\par ??            target.Set(key, values);\par ??\par ??            \cf4 string\cf0 [] actual = target.Get(key);\par ??            \cf3 Assert\cf0 .IsTrue(ContainsAllIn(actual, values));\par ??        \}\par ??\par ??        [\cf3 Test\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  old_values__should_persist__when_adding_new_ones()\par ??        \{\par ??            \cf4 var\cf0  target = \cf4 new\cf0  \cf3 PersistentCache\cf0 ();\par ??            \cf4 var\cf0  key = \cf5 "/"\cf0 ;\par ??            \cf4 string\cf0 [] values = \{ \cf5 "/"\cf0 , \cf5 "/foo"\cf0  \};\par ??            target.Set(key, values);\par ??\par ??            \cf4 string\cf0 [] otherValues = \{\cf5 "/foo/bar"\cf0 , \cf5 "/test.txt"\cf0 \};\par ??            target.Set(key, otherValues);\par ??            \cf4 string\cf0 [] actual = target.Get(key);\par ??            \cf3 Assert\cf0 .IsTrue(ContainsAllIn(actual, values));\par ??            \cf3 Assert\cf0 .IsTrue(ContainsAllIn(actual, otherValues));\par ??        \}\par ??\par ??        [\cf3 Test\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  get__should_return_empty_array__when_key_does_not_exist()\par ??        \{\par ??            \cf4 var\cf0  target = \cf4 new\cf0  \cf3 PersistentCache\cf0 ();\par ??            \cf4 var\cf0  key = \cf5 "/"\cf0 ;\par ??            \cf4 string\cf0 [] values = \{ \cf5 "/"\cf0 , \cf5 "/foo"\cf0  \}; \par ??            target.Set(key, values);\par ??            \cf4 var\cf0  key2 = \cf5 "boo"\cf0 ;\par ??            \cf3 Assert\cf0 .IsNull((target.Get(key2)));\par ??        \}\par ??\par ??        \cf4 public\cf0  \cf4 static\cf0  \cf4 bool\cf0  ContainsAllIn(\cf4 string\cf0 [] actual, \cf4 string\cf0 [] array)\par ??        \{\par ??            \cf4 var\cf0  actualValues = \cf4 new\cf0  \cf3 List\cf0 &lt;\cf4 string\cf0 &gt;(actual);\par ??            \cf4 foreach\cf0  (\cf4 string\cf0  s \cf4 in\cf0  array)\par ??            \{\par ??                \cf4 if\cf0  (!actualValues.Contains(s))\par ??                    \cf4 return\cf0  \cf4 false\cf0 ;\par ??            \}\par ??            \cf4 return\cf0  \cf4 true\cf0 ;\par ??        \}\par ??\par ??    \}\par ??}<br />--><br /><div style="font-family: Courier New; font-size: 10pt; color: black; background: white;"><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Test</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> get__should_return_the_files__when_key_exists()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> target = <span style="color: blue;">new</span> <span style="color: #2b91af;">PersistentCache</span>();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> key = <span style="color: #a31515;">"/"</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] values = { <span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span> };</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; target.Set(key, values);</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] actual = target.Get(key);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(ContainsAllIn(actual, values));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Test</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> old_values__should_persist__when_adding_new_ones()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> target = <span style="color: blue;">new</span> <span style="color: #2b91af;">PersistentCache</span>();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> key = <span style="color: #a31515;">"/"</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] values = { <span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span> };</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; target.Set(key, values);</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] otherValues = {<span style="color: #a31515;">"/foo/bar"</span>, <span style="color: #a31515;">"/test.txt"</span>};</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; target.Set(key, otherValues);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] actual = target.Get(key);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(ContainsAllIn(actual, values));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(ContainsAllIn(actual, otherValues));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Test</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> get__should_return_empty_array__when_key_does_not_exist()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> target = <span style="color: blue;">new</span> <span style="color: #2b91af;">PersistentCache</span>();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> key = <span style="color: #a31515;">"/"</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">string</span>[] values = { <span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span> }; </p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; target.Set(key, values);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> key2 = <span style="color: #a31515;">"boo"</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsNull((target.Get(key2)));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">static</span> <span style="color: blue;">bool</span> ContainsAllIn(<span style="color: blue;">string</span>[] actual, <span style="color: blue;">string</span>[] array)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> actualValues = <span style="color: blue;">new</span> <span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">string</span>&gt;(actual);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">foreach</span> (<span style="color: blue;">string</span> s <span style="color: blue;">in</span> array)</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">if</span> (!actualValues.Contains(s))</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">false</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">true</span>;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /></div><br /><br /><!--<br />{\rtf1\ansi\ansicpg\lang1024\noproof65001\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Courier New;}}{\colortbl;??\red0\green0\blue0;\red255\green255\blue255;\red43\green145\blue175;\red0\green0\blue255;\red163\green21\blue21;}??\fs20     [\cf3 TestFixture\cf0 ]\par ??    \cf4 public\cf0  \cf4 class\cf0  \cf3 FileSystemCacheTests\par ??\cf0     \{\par ??        \cf4 readonly\cf0  \cf3 PersistentCache\cf0  cache = \cf4 new\cf0  \cf3 PersistentCache\cf0 ();\par ??        \cf4 private\cf0  \cf3 FileSystemCache\cf0  fsc;\par ??\par ??        [\cf3 SetUp\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  SetUp()\par ??        \{\par ??            fsc = \cf4 new\cf0  \cf3 FileSystemCache\cf0 (cache);\par ??            fsc.Add(\cf4 new\cf0 []\par ??                        \{\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 1, Name = \cf5 "/"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 1, Name = \cf5 "/foo"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 1, Name = \cf5 "/foo/bar"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 1, Name = \cf5 "/foo/bar/text.txt"\cf0 \},\par ??                        \});\par ??            fsc.Add(\cf4 new\cf0 []\par ??                        \{\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 2, Name = \cf5 "/"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 2, Name = \cf5 "/foo"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 2, Name = \cf5 "/foo/bar"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 2, Name = \cf5 "/foo/bar/text.txt"\cf0 \},\par ??                            \cf4 new\cf0  \cf3 VersionedFile\cf0  \{Version = 2, Name = \cf5 "/test.txt"\cf0 \},\par ??                        \});\par ??        \}\par ??\par ??        [\cf3 Test\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  should_be_able_to_get_files__without_recursion()\par ??        \{\par ??            \cf4 var\cf0  actual = fsc.ListFilesAndFolders(\cf5 "/"\cf0 , 1, \cf3 Recursion\cf0 .None);\par ??            \cf3 Assert\cf0 .IsTrue(\cf3 PersistentCacheTest\cf0 .ContainsAllIn(actual, \cf4 new\cf0  [] \{ \cf5 "/"\cf0  \}));\par ??        \}\par ??\par ??        [\cf3 Test\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  should_be_able_to_get_files__with_one_level_recursion()\par ??        \{\par ??            \cf4 var\cf0  actual = fsc.ListFilesAndFolders(\cf5 "/"\cf0 , 1, \cf3 Recursion\cf0 .OneLevel);\par ??            \cf3 Assert\cf0 .IsTrue(\cf3 PersistentCacheTest\cf0 .ContainsAllIn(actual, \cf4 new\cf0  [] \{ \cf5 "/"\cf0 , \cf5 "/foo"\cf0  \}));\par ??        \}\par ??\par ??\par ??\par ??        [\cf3 Test\cf0 ]\par ??        \cf4 public\cf0  \cf4 void\cf0  should_be_able_to_get_files__with_full_recursion()\par ??        \{\par ??            \cf4 var\cf0  actual = fsc.ListFilesAndFolders(\cf5 "/"\cf0 , 1, \cf3 Recursion\cf0 .Full);\par ??            \cf4 var\cf0  expected = \cf4 new\cf0 [] \{\cf5 "/"\cf0 , \cf5 "/foo"\cf0 , \cf5 "/foo/bar"\cf0 , \cf5 "/foo/bar/text.txt"\cf0 \};\par ??            \cf3 Assert\cf0 .IsTrue(\cf3 PersistentCacheTest\cf0 .ContainsAllIn(actual, expected));\par ??            expected = \cf4 new\cf0 [] \{ \cf5 "/"\cf0 , \cf5 "/foo"\cf0 , \};\par ??            actual = fsc.ListFilesAndFolders(\cf5 "/"\cf0 , 1, \cf3 Recursion\cf0 .OneLevel);\par ??            \cf3 Assert\cf0 .IsTrue(\cf3 PersistentCacheTest\cf0 .ContainsAllIn(actual, expected));\par ??            actual = fsc.ListFilesAndFolders(\cf5 "/"\cf0 , 2, \cf3 Recursion\cf0 .OneLevel);\par ??            expected = \cf4 new\cf0 [] \{ \cf5 "/"\cf0 , \cf5 "/foo"\cf0 , \cf5 "/test.txt"\cf0  \};\par ??            \cf3 Assert\cf0 .IsTrue(\cf3 PersistentCacheTest\cf0 .ContainsAllIn(actual, expected));\par ??        \}\par ??    \}}<br />--><br /><div style="font-family: Courier New; font-size: 10pt; color: black; background: white;"><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">TestFixture</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">FileSystemCacheTests</span></p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">readonly</span> <span style="color: #2b91af;">PersistentCache</span> cache = <span style="color: blue;">new</span> <span style="color: #2b91af;">PersistentCache</span>();</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span> <span style="color: #2b91af;">FileSystemCache</span> fsc;</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">SetUp</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> SetUp()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fsc = <span style="color: blue;">new</span> <span style="color: #2b91af;">FileSystemCache</span>(cache);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fsc.Add(<span style="color: blue;">new</span>[]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 1, Name = <span style="color: #a31515;">"/"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 1, Name = <span style="color: #a31515;">"/foo"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 1, Name = <span style="color: #a31515;">"/foo/bar"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 1, Name = <span style="color: #a31515;">"/foo/bar/text.txt"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; });</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fsc.Add(<span style="color: blue;">new</span>[]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 2, Name = <span style="color: #a31515;">"/"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 2, Name = <span style="color: #a31515;">"/foo"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 2, Name = <span style="color: #a31515;">"/foo/bar"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 2, Name = <span style="color: #a31515;">"/foo/bar/text.txt"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">VersionedFile</span> {Version = 2, Name = <span style="color: #a31515;">"/test.txt"</span>},</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; });</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Test</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> should_be_able_to_get_files__without_recursion()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> actual = fsc.ListFilesAndFolders(<span style="color: #a31515;">"/"</span>, 1, <span style="color: #2b91af;">Recursion</span>.None);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(<span style="color: #2b91af;">PersistentCacheTest</span>.ContainsAllIn(actual, <span style="color: blue;">new</span> [] { <span style="color: #a31515;">"/"</span> }));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Test</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> should_be_able_to_get_files__with_one_level_recursion()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> actual = fsc.ListFilesAndFolders(<span style="color: #a31515;">"/"</span>, 1, <span style="color: #2b91af;">Recursion</span>.OneLevel);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(<span style="color: #2b91af;">PersistentCacheTest</span>.ContainsAllIn(actual, <span style="color: blue;">new</span> [] { <span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span> }));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Test</span>]</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> should_be_able_to_get_files__with_full_recursion()</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> actual = fsc.ListFilesAndFolders(<span style="color: #a31515;">"/"</span>, 1, <span style="color: #2b91af;">Recursion</span>.Full);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> expected = <span style="color: blue;">new</span>[] {<span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span>, <span style="color: #a31515;">"/foo/bar"</span>, <span style="color: #a31515;">"/foo/bar/text.txt"</span>};</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(<span style="color: #2b91af;">PersistentCacheTest</span>.ContainsAllIn(actual, expected));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; expected = <span style="color: blue;">new</span>[] { <span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span>, };</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; actual = fsc.ListFilesAndFolders(<span style="color: #a31515;">"/"</span>, 1, <span style="color: #2b91af;">Recursion</span>.OneLevel);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(<span style="color: #2b91af;">PersistentCacheTest</span>.ContainsAllIn(actual, expected));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; actual = fsc.ListFilesAndFolders(<span style="color: #a31515;">"/"</span>, 2, <span style="color: #2b91af;">Recursion</span>.OneLevel);</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; expected = <span style="color: blue;">new</span>[] { <span style="color: #a31515;">"/"</span>, <span style="color: #a31515;">"/foo"</span>, <span style="color: #a31515;">"/test.txt"</span> };</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #2b91af;">Assert</span>.IsTrue(<span style="color: #2b91af;">PersistentCacheTest</span>.ContainsAllIn(actual, expected));</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p><br /><p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ayende's Challenge]]></title>
    <link href="http://www.sharpbites.com/2008/04/09/ayendes-challenge/"/>
    <updated>2008-04-09T00:00:00+02:00</updated>
    <id>http://www.sharpbites.com/2008/04/09/ayendes-challenge</id>
    <content type="html"><![CDATA[<div class='post'>
<a href="http://www.ayende.com/">Ayende</a> <a href="http://www.ayende.com/Blog/archive/2008/04/09/A-challenge-Getting-a-list-of-products.aspx">challenged</a> the whole intarweb to resolve a problem similar to the ones he uses in his job interviews. It goes like this:<br /><blockquote>The task is listing the first 10 products that we can sell to a customer. The UI is console application, and the database design and data access method are whatever you want.</blockquote><br />Additionally you have to filter those products according to some arguments given as input parameters to the application (representing different categorizations of products).<br /><br />Now, my solution. :)<br /><pre name="code" class="c-sharp"><br />    public enum Category<br />    {<br />        PG13,<br />        Vegetarian<br />    }<br /><br />    public class Product<br />    {<br />        public string Name { get; set; }<br />        public decimal Price { get; set; }<br />        public IList<Category> Categories { get; set;}<br /><br />        public override string ToString()<br />        {<br />            return string.Format("{0}\t{1}", Name, Price);<br />        }<br />    }<br /><br />    public class Filter<br />    {<br />        public static IEnumerable<Product> ApplyFilter(IEnumerable<Product> products, Category category)<br />        {<br />            return from p in products where p.Categories.Contains(category) select p; <br />        }<br />    }<br /><br />    class Program<br />    {<br />        static void Main(string[] args)<br />        {<br />            var categoryMapper = new Dictionary<string, Category><br />                                     {<br />                                         {"-pg13", Category.PG13},<br />                                         {"-vegetarian", Category.Vegetarian}<br />                                     };<br /><br />            var products = new List<Product><br />                               {<br />                                   new Product {Name = "Milk", Price = 1.0M, <br />                                       Categories = new List<Category> {Category.PG13, Category.Vegetarian}}, <br />                                   new Product {Name = "Bread", Price = 1.3M, <br />                                       Categories = new List<Category> {Category.PG13, Category.Vegetarian}},<br />                                   new Product {Name = "Sausage", Price = 2.5M, <br />                                       Categories = new List<Category> {Category.PG13}},<br />                                   new Product {Name = "Horror Movie", Price = 5.0M, <br />                                       Categories = new List<Category> {Category.Vegetarian}}<br />                               };<br /><br />            var filteredResults = (IEnumerable<Product>) products;<br />            foreach (string arg in args)<br />            {<br />                if (categoryMapper.ContainsKey(arg))<br />                {<br />                    filteredResults = Filter.ApplyFilter(filteredResults, categoryMapper[arg]);<br />                }<br />            }<br /><br />            filteredResults = filteredResults.Take(10);<br /><br />            foreach (Product product in filteredResults)<br />            {<br />                Console.Out.WriteLine(product);<br />            }<br />        }<br />    }<br /><br /></pre></div>

]]></content>
  </entry>
  
</feed>
